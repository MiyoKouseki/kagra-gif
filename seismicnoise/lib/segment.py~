import logger
log = logger.Logger(__name__)

import numpy as np
from gwpy.segments import Segment,SegmentList
from plot import plot_asd,plot_timeseries # kesu!

from io import fname_gwf,fname_png_ts,fname_png_asd,fname_hdf5_sg

def diff(seglist,nodata):
    new = SegmentList()
    for segment in seglist:
        flag = 0
        for _nodata in nodata:
            if segment != _nodata:
                flag += 1
            else:
                break
        if flag==len(nodata):
            new.append(segment)
    return new


def random_segments(start,end,bins=4096,nseg=10,seed=3434,**kwargs):
    ''' Return segment list randomly in term you designated
    
        
    Parameters
    ----------
    start : `float`
        Start time 
    end : `float`
        End time
    nseg : `int`, optional
        The number of segments
    seed : `int`, optional
        Seed. 3434 is a default value.
    bins : `int`, optional
        Duration. default is 3600 seconds.    
    write : `Bool`, optional
        If True, segmentlist is written in local directory. Default is True.

    Returns
    -------
    segmentlist : `gwpy.segments.SegmentList`
        SegmentList.
    '''
    from numpy.random import randint

    write = kwargs['write']

    np.random.seed(seed=seed)
    ini = range(start,end,bins)
    _start = np.array([ ini[randint(0,len(ini))] for i in range(0,nseg)])
    _end = _start + bins
    segmentlist = SegmentList(map(Segment,zip(_start,_end)))

    if write:
        segmentlist.write('./segmentlist/random.txt')

    return segmentlist


def divide_segmentlist(start,end,bins=4096,write=True,**kwargs):
    ''' Divide given period to segmenlist
    
    Parameters
    ----------
    start : `int`
        GPS start time of given period
    end : `int`
        GPS end time of given period
    bins : `int`, optional
        The number of bins. Unit is second. Default value is 4096 =(2**12).

    Returns
    -------
    segmentlist : `gwpy.segment.SegmentList`
        Divided segmentlist
    '''
    if ((end-start) % bins) != 0:
        raise ValueError('Not divisible!')

    _start = range(start     ,end     ,bins)
    _end   = range(start+bins,end+bins,bins)
    segmentlist = SegmentList([Segment(s,e) for s,e in zip(_start,_end)])

    if write:
        segmentlist.write('./segmentlist/total.txt')
        
    return segmentlist



def read_segmentlist(total,skip=True,**kwargs):
    '''
    '''
    if skip:
        log.debug('Skip chekking segment')
        total  = SegmentList.read('./segmentlist/total.txt')
        none   = SegmentList.read('./segmentlist/none.txt')
        good   = SegmentList.read('./segmentlist/good.txt')
        lack   = SegmentList.read('./segmentlist/lack.txt')
        glitch = SegmentList.read('./segmentlist/glitch.txt')
    else:
        good,none        = check_nodata(total,**kwargs)
        good,lack,glitch = check_badsegment(good,**kwargs)
        log.debug('Checking done. Close.')
        exit()
    if not (len(total)-len(none)-len(lack)-len(glitch)==len(good)):
        log.debug('SegmentListError!')
        raise ValueError('Missmatch SegmentLists!')
    return good,none,lack,glitch




def _check_nodata(sources,chname,start,end,sample_freq=32,prefix='./data',**kwargs):
    '''

    Parameters
    ----------
    sources : list of str
        Path to sources. 
    chname :  list of str
        Channel names. It's passed to 
    start : int
    end : int
    sample_freq : int
    
    '''    
    write_gwf = kwargs.pop('write_gwf',True)
    try:
        data = TimeSeriesDict.read(sources,chname,**kwargs)
        data = data.resample(sample_freq)
        data = data.crop(start,end)
        [d.override_unit('ct') for d in data.values()]
        assert None not in [d.name for d in data.values()], 'not exit!'
    except ValueError as e:
        #log.debug(traceback.format_exc())
        return 'No Data 01'
    except RuntimeError as e:       
        #log.debug(traceback.format_exc())
        return 'No Data 02'
    except IndexError as e:
        #log.debug(traceback.format_exc())
        return 'No Data 03'
    except:
        log.debug(traceback.format_exc())
        raise ValueError('Unknown error. Please comfirm.')    
    if write_gwf:
        fname = fname_gwf(start,end,prefix)
        try:
            data.write(fname,format='gwf.lalframe')
            return 'OK. Wrote'
        except:
            log.debug(traceback.format_exc())            
            raise ValueError('AAAAAA')
    return 'OK. Exists.'

    # mtrend 1211814000
    # strend 1211814000
    # full   1211814016, 1211817600
    # 1211817600



def check_nodata(segmentlist,prefix='./data',**kwargs):
    ''' 
    
    '''
    log.debug('Save timeseriesdict..')
    from Kozapy.utils import filelist
    skip = kwargs.pop('skip',False)
    check = kwargs.pop('check',True)
    write = kwargs.pop('write',True)
    fnames = [fname_gwf(start,end,prefix) for start,end in segmentlist]
    exists = [os.path.exists(fname) for fname in fnames]

    # 
    checked = [segmentlist[i] for i,exist in enumerate(exists) if exist]
    log.debug('{0}(/{1}) segments are existed.'.format(len(checked),len(segmentlist)))
    if len(checked)==len(segmentlist):
        log.debug('Then, all segments are existed.')
        return segmentlist,nodata
    # 
    not_checked = [segmentlist[i] for i,exist in enumerate(exists) if not exist]
    log.debug('{0}(/{1}) are not checked'.format(len(not_checked),len(segmentlist)))
    n = len(not_checked)
    nodata = SegmentList()
    for i,segment in enumerate(not_checked):
        chname = get_seis_chname(segment[0],segment[1])
        sources = filelist(segment[0],segment[1])
        ans = _check_nodata(sources,chname,segment[0],segment[1],**kwargs)
        fname = fname_gwf(segment[0],segment[1],prefix)
        log.debug('{0:03d}/{1:03d} {2} '.format(i+1,n,fname) + ans)
        if 'No Data' in ans:
            nodata.append(segment)

    exist = diff(segmentlist,nodata)
    if len(exist)==0:
        log.debug('No data are existed...')
        raise ValueError('No data Error.')
    if write:
        exist.write('./segmentlist/exist.txt')
        nodata.write('./segmentlist/nodata.txt')

    log.debug('{0} segments are existed'.format(len(exist)))
    return exist,nodata


def _check_badsegment(segment,data=None,prefix='./data',**kwargs):
    ''' Check whether given segment is good or not.
    
    1. Read timeseriese data from frame file saved in local place. 
       If data could not be read, return "No Data" flag.
    2. Check lack of data. 
    

    1 bit : no data
    2 bit : lack of data
    3 bit : missed caliblation 
    4 bit : big earthquake
    '''    
    start,end = segment
    fname = fname_gwf(start,end,prefix)
    chname = get_seis_chname(start,end)    
    try:
        data = TimeSeriesDict.read(fname,chname,verbose=False,**kwargs)
        lack_of_data = any([0.0 in d.value for d in data.values()] )*4
        miss_calib = any([ 1000.0 < d.mean() for d in data.values()])*8
        bigeq = any([any((d.std()*6)<(d-d.mean()).abs().value) for d in data.values()])*16
        return data, (lack_of_data + miss_calib + bigeq)
    except IOError as e:
        nodata = (True)*2
        return None, nodata
    except ValueError as e:
        if 'Cannot append discontiguous TimeSeries' in e.args[0]:
            log.debug(e)
            nodata = (True)*2
            return None, nodata
        else:
            log.debug(traceback.format_exc())
            raise ValueError('!!')
    except:
        log.debug(traceback.format_exc())
        raise ValueError('!!!')


def check_badsegment(seglist,prefix='./data',**kwargs):
    '''

    '''
    log.debug('Checking bad segments')
    
        
    status = {2:'no_data',
              4:'lack_of_data',
              8:'miss_calib',
              16:'big_eq'}

    write = kwargs.pop('write',True)

    prefix = kwargs.pop('prefix','./data')
    fnames = [fname_png_ts(start,end,prefix) for start,end in seglist]
    exists = [os.path.exists(fname) for fname in fnames]
    checked = [seglist[i] for i,exist in enumerate(exists) if exist]
    not_checked = [seglist[i] for i,exist in enumerate(exists) if not exist]
    
    bad = SegmentList()
    eq = SegmentList()
    for i,segment in enumerate(seglist):
        data,bad_status = _check_badsegment(segment,**kwargs)
        if bad_status-16>=0:
            eq.append(segment)
        elif bad_status and not (bad_status-16>=0):
            bad.append(segment)
        elif not bad_status:            
            pass
        else:
            log.debug(bad_status)
            log.debug('!')
            raise ValueError('!')
        start,end = segment
        fname_img = fname_png_ts(start,end,prefix)
        log.debug('{0:03d}/{1:03d} {2} {3}'.format(i,len(seglist),fname_img,bad_status))
        chname = get_seis_chname(start,end)
        if plot and not os.path.exists(fname_img):
            plot_timeseries(data,start,end,bad_status,fname_img)
    # 
    new = SegmentList()    
    for segment in seglist:
        flag = 0
        for _bad in bad:
            if segment != _bad:
                flag += 1
            else:
                break
        if flag==len(bad):
            new.append(segment)
    seglist = new
    new = SegmentList()    
    for segment in seglist:
        flag = 0
        for _eq in eq:
            if segment != _eq:
                flag += 1
            else:
                break
        if flag==len(eq):
            new.append(segment)
    if write:
        new.write('./segmentlist/available.txt')    
        bad.write('./segmentlist/lackofdata.txt')
        eq.write('./segmentlist/glitch.txt')
    return new,bad,eq
