#
#! coding:utf-8
import os
from numpy.random import randint
import numpy as np
import traceback

import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt

import subprocess
from gwpy.segments import Segment,SegmentList,DataQualityFlag
from gwpy.time import tconvert
from gwpy.timeseries import TimeSeries,TimeSeriesDict
from gwpy.frequencyseries import FrequencySeries
from gwpy.spectrogram import Spectrogram

from Kozapy.utils import filelist

gwf_fmt = './data/{0}_{1}_{2}_{3}.gwf'
img_fmt = './data/img_ASD_{0}_{1}.png'
img_ts_fmt = './data/img_TS_{0}_{1}_{2}_{3}.png'
sg_fmt = './data/sg_{axis}_{s}_{e}.hdf5'

def fw_segments(fw_name='fw0',scp=False):
    ''' Return the segment list when the frame writer could write data.

    Information about when the fw0 write data is given by a text file named "fw0-latest.txt".  This text file is generated by a script written by T. Yamamoto. Then we can make a segment list by translating this file.

    "fw0-latest.txt" is saved on /users/DGS/Frame.

    Parameters
    ----------
    fw_name : `str`, optional
        Name of the frame writer. KAGRA have a fw0 and fw1. Default is fw0.
    scp : `str`, optional
        If download from control machine, please choose True. In default, False.

    Returns
    -------
    ok : `gwpy.segments.SegmentList`
        SegmentList whihch only contain segments when fw has write data on main strage.
    '''
    if scp:
        cmd = 'scp controls@k1ctr7:/users/DGS/Frame/{0}-latest.txt ./ '.format(fw_name)
        download = subprocess.call(cmd, shell=True)

    cmd = "less ./{0}-latest.txt".format(fw_name) 
    cmd += " | awk '{if ($4>86400) print $1 , $2}' > tmp_{0}.txt".format(fw_name)
    make_tmp_txt = subprocess.call(cmd,shell=True)
    ok = SegmentList.read('tmp_{0}.txt'.format(fw_name))
    remove_tmp_txt = subprocess.call("rm tmp_{0}.txt".format(fw_name), shell=True)
    return ok


def random_segments(start,end,tlen=3600,n=200,seed=3434):
    ''' Return segment list randomly in term you designated
    
        
    Parameters
    ----------
    start : `float`
        Start time 
    end : `float`
        End time
    n : `int`, optional
        The number of segments
    seed : `int`, optional
        Seed. 3434 is a default value.
    tlen : `int`, optional
        Duration. default is 3600 seconds.    
    write : `Bool`, optional
        If True, segmentlist is written in local directory. Default is True.

    Returns
    -------
    segmentlist : `gwpy.segments.SegmentList`
        SegmentList.
    '''
    np.random.seed(seed=seed)        
    _start = randint(start,end,size=n)
    _end = _start + tlen
    segmentlist = SegmentList(map(Segment,zip(_start,_end)))
    return segmentlist

def read_and_write_timeseries(sources,chname,start,end,fname,**kwargs):
    '''
    '''
    nds = kwargs.pop('nds',True)
    try:
        if nds:
            data = TimeSeriesDict.fetch(chname,host='10.68.10.122',
                                        port=8088,verbose=False,pad=0.0)            
        else:
            data = TimeSeriesDict.read(sources,chname,**kwargs)
        data = data.crop(start,end)
        assert None not in [d.name for d in data.values()], 'not exit!'
        data.write(fname,format='gwf.lalframe')
        ok = True
    except:                    
        print traceback.format_exc()
        ok = False
    return ok

def save_timeseriesdict(segmentlist,chname,nds=True,trend='minute',stype='rms',nproc=2):
    ''' 
    
    '''
    print('Save timeseriesdict..')

    if not trend=='full':
        chname = [ch+'.'+stype for ch in chname]
    if trend=='full':
        stype = ''

    for i,segment in enumerate(segmentlist):
        start, end = segment
        sources = filelist(start,end,trend=trend,place='kashiwa')
        fname = gwf_fmt.format(trend,stype,start,end)
        if not os.path.exists(fname):
            kwargs = {'format':'gwf.lalframe','nproc':nproc,'pad':0.0,'nds':nds}
            ok = read_and_write_timeseries(sources,chname,start,end,fname,**kwargs)
            if ok:
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname,'Saving..'
            else:
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname,'No Data'
        else:
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname,'File exist'
    

def check_badsegment(segmentlist,chname,plot=True,nproc=2,stype='',trend='minute'):
    '''

    '''
    print('Check bad segments')

    if not trend=='full':
        chname = [ch+'.'+stype for ch in chname]

    nodata = False
    baddata = False
    lack_of_data = False
    bad = SegmentList()
    for i,segment in enumerate(segmentlist):
        start,end = segment        
        fname = gwf_fmt.format(trend,stype,start,end)
        try:
            data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
            dame = True in [ 1000.0 < d.mean() for d in data.values()]
            lack_of_data = True in [0.0 in d.value for d in data.values()]
            bigeq = True in [0.1 < d.diff().abs().max().value for d in data.values()]
            baddata = lack_of_data or bigeq or dame
            if baddata:
                bad.append(segment)
        except IOError as e:
            bad.append(segment)
            nodata = True
        except:
            print traceback.format_exc()
            baddata = True
            nodata = True
            raise ValueError('!!!')
        
        fname_img = img_ts_fmt.format(trend,stype,start,end)
        if plot and not os.path.exists(fname_img) and not nodata:
            label = [d.replace('_','\_') for d in data]
            _plot = data.plot(ylabel='Velocity [um/sec]',epoch=start,
                             ylim=(0,1),title='BLRMS\_100M\_300M')
            ax = _plot.gca()
            ax.plot(data.values()[0].diff().abs(),'k--')
            ax.plot(data.values()[1].diff().abs(),'r--')
            ax.plot(data.values()[2].diff().abs(),'b--')
            ax.legend(label + ['X Diffs','Y Diffs','Z Diffs'])
            if baddata:
                ax.axvspan(start, end, alpha=0.5, color='red')
            _plot.savefig(fname_img)
            _plot.close()
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,nodata,bigeq,dame
    # 
    new = SegmentList()    
    for segment in segmentlist:
        flag = 0
        for _bad in bad:
            if segment != _bad:
                flag += 1
            else:
                break
        print flag,len(bad)
        if flag==len(bad):
            new.append(segment)
    return new,bad

def plot_asd(segment,data,fname_img,fname_hdf5,**kwargs):
    '''
    '''
    axis = ['X','Y','Z']    
    fig ,ax = plt.subplots(1,1)
    nproc = kwargs.pop('nproc',2)
    for i,d in enumerate(data.values()):
        sg = d.spectrogram2(fftlength=100, overlap=50,nproc=nproc) ** (1/2.)
        asd = sg.percentile(50)        
        _fname_hdf5 = fname_hdf5.format(axis=axis[i])
        print ' -: ',_fname_hdf5,'Save'
        sg.write(_fname_hdf5,format='hdf5',overwrite=True)
        ax.loglog(asd,label=d.name.replace('_','\_'))
    ax.legend(loc='lower left')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig(fname_img)
    plt.close()


def save_spectrogram(segmentlist,chname,plot=True,nproc=2,write=True,nodata=False,trend='full',stype=''):
    '''
    '''
    

    print('Save spectrograms ')
    bad = SegmentList()
    chname = [ch.split(',')[0] for ch in chname]
    for i,segment in enumerate(segmentlist):
        start,end = segment        
        fname = gwf_fmt.format(trend,stype,start,end)
        try:
            data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
        except:            
            nodata = True
        label = [d.replace('_','\_') for d in data]        
        fname_img = img_fmt.format(start,end)
        fname_hdf5 = sg_fmt.format(axis='{axis}',s=start,e=end)
        if os.path.exists(fname_img):
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,'Exist'
        elif not nodata and plot:
            kwargs={'nproc':nproc}
            plot_asd(segment,data,fname_img,fname_hdf5,**kwargs)
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,'Plot'
        elif nodata:
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,'No Data'
        else:
            raise ValueError('!')


def plot_averaged_asd(specgrams):
    '''
    '''
    fig ,ax = plt.subplots(1,1)
    median = specgrams.percentile(50)
    low = specgrams.percentile(5)
    high = specgrams.percentile(95)
    ax.plot_mmm(median, low, high, color='gwpy:ligo-hanford')    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    fname_hdf5 = './data/ASD_LongTerm_{0}.hdf5'.format(axis)
    plt.savefig('./data/img_ASD_LongTerm_{0}.png'.format(axis))
    print ('Plot ./data/img_ASD_LongTerm_{0}.png'.format(axis))
    specgrams.write(fname_hdf5,format='hdf5',overwrite=True)
    plt.close()


def plot_segmentlist(segmentlist):
    '''
    '''
    pass
            
if __name__ == "__main__":
    import warnings
    warnings.filterwarnings('ignore')

    # ----------------------------------------    
    # Setting
    # ----------------------------------------    
    segnum = 2
    seed = 3434
    start = int(tconvert("Feb 01 2019 00:00:00 JST"))
    end = int(tconvert("Jun 24 2019 00:00:00 JST"))
    chname = ['K1:PEM-SEIS_EXV_GND_X_OUT16',
              'K1:PEM-SEIS_EXV_GND_Y_OUT16',
              'K1:PEM-SEIS_EXV_GND_Z_OUT16']
    nproc = 10
    trend = 'full'
    # ----------------------------------------    
    print('1. Save all time-series data in local directory.')
    # ----------------------------------------
    random = random_segments(start,end,tlen=3600,n=segnum,seed=seed)
    save_timeseriesdict(random,chname,nds=False,trend='full',nproc=nproc)
    random.write('random.txt')

    # ----------------------------------------    
    print('2. Check whether earthquake or lacking of data happen in the given segment.')
    # ----------------------------------------    
    good,bad = check_badsegment(random,chname,trend='full',nproc=nproc)
    good.write('good.txt')
    bad.write('bad.txt')
    plot_segmentlist(good)

    # ----------------------------------------    
    print('3. Save spectrograms with all timeseries data in local directory')
    # ----------------------------------------        
    save_spectrogram(noeq,chname,nproc=nproc)

    # ----------------------------------------    
    print('4. Calculate ASD avelaged with all spectrogram segments')
    # ----------------------------------------            
    axis = 'X'
    fname = filter(lambda x: "sg_{0}".format(axis) in x, os.listdir('./data'))
    fname = map(lambda x:'./data/'+x,fname)
    specgrams = Spectrogram.read(fname[0],format='hdf5')
    for fname in fname[1:]:
        specgrams.append(Spectrogram.read(fname,format='hdf5'),gap='ignore')        
    plot_averaged_asd(specgrams)
    
