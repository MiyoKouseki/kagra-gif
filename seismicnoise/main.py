#
#! coding:utf-8
import os
from numpy.random import rand
import numpy as np
import traceback

import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt

import subprocess
from gwpy.segments import Segment,SegmentList,DataQualityFlag
from gwpy.time import tconvert
from gwpy.timeseries import TimeSeries,TimeSeriesDict
from gwpy.frequencyseries import FrequencySeries
from gwpy.spectrogram import Spectrogram

from Kozapy.utils import filelist


def fw_segments(fw_name='fw0',scp=False):
    ''' Return the segment list when the frame writer could write data.

    Information about when the fw0 write data is given by a text file named "fw0-latest.txt".  This text file is generated by a script written by T. Yamamoto. Then we can make a segment list by translating this file.

    "fw0-latest.txt" is saved on /users/DGS/Frame.

    Parameters
    ----------
    fw_name : `str`, optional
        Name of the frame writer. KAGRA have a fw0 and fw1. Default is fw0.
    scp : `str`, optional
        If download from control machine, please choose True. In default, False.

    Returns
    -------
    ok : `gwpy.segments.SegmentList`
        SegmentList whihch only contain segments when fw has write data on main strage.
    '''
    if scp:
        cmd = 'scp controls@k1ctr7:/users/DGS/Frame/{0}-latest.txt ./ '.format(fw_name)
        download = subprocess.call(cmd, shell=True)

    cmd = "less ./{0}-latest.txt".format(fw_name) 
    cmd += " | awk '{if ($4>86400) print $1 , $2}' > tmp_{0}.txt".format(fw_name)
    make_tmp_txt = subprocess.call(cmd,shell=True)
    ok = SegmentList.read('tmp_{0}.txt'.format(fw_name))
    remove_tmp_txt = subprocess.call("rm tmp_{0}.txt".format(fw_name), shell=True)
    return ok


def random_segments(start,end,tlen=3600,n=200,seed=3434,write=True):
    ''' Return segment list randomly in term you designated
    
        
    Parameters
    ----------
    start : `float`
        Start time 
    end : `float`
        End time
    n : `int`, optional
        The number of segments
    seed : `int`, optional
        Seed. 3434 is a default value.
    tlen : `int`, optional
        Duration. default is 3600 seconds.    
    write : `Bool`, optional
        If True, segmentlist is written in local directory. Default is True.

    Returns
    -------
    segmentlist : `gwpy.segments.SegmentList`
        SegmentList.
    '''
    np.random.seed(seed=seed)        
    _start = start*np.ones(n) + (end-start)*rand(n)
    _end = _start + tlen
    segmentlist = SegmentList(map(Segment,zip(_start,_end)))
    if write:
        segmentlist.write('random.txt')
        print('saved random.txt')
    return segmentlist

def read_and_write_timeseries(sources,chname,start,end,fname,**kwargs):
    '''
    '''
    nds = kwargs.pop('nds',True)
    try:
        if nds:
            data = TimeSeriesDict.fetch(chname,host='10.68.10.122',
                                        port=8088,verbose=False,pad=0.0)            
        else:
            data = TimeSeriesDict.read(sources,chname,**kwargs)
        data = data.crop(int(start),int(end))
        assert None not in [d.name for d in data.values()], 'not exit!'
        data.write(fname,format='gwf.lalframe')
        ok = True
    except:                    
        print traceback.format_exc()
        ok = False
    return ok

def save_timeseriesdict(segmentlist,chname,nds=True,trend='minute',stype='rms',nproc=2):
    ''' 
    
    '''
    print('Save timeseriesdict..')

    if not trend=='full':
        chname = [ch+'.'+stype for ch in chname]
    if trend=='full':
        stype = ''

    for i,segment in enumerate(segmentlist):
        start, end = segment
        sources = filelist(start,end,trend=trend,place='kashiwa')
        fname = './data/{0}_{1}_{2}_{3}.gwf'.format(trend,stype,int(start),int(end))
        if not os.path.exists(fname):
            kwargs = {'format':'gwf.lalframe','nproc':nproc,'pad':0.0,'nds':nds}
            ok = read_and_write_timeseries(sources,chname,start,end,fname,**kwargs)
            if ok:
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname,'Saving..'
            else:
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname,'No Data'
        else:
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname,'File exist'
    

def check_badsegment(segmentlist,chname,plot=True,nproc=2,stype='rms',trend='minute'):
    '''

    '''
    print('Check bad segments')

    if not trend=='full':
        chname = [ch+'.'+stype for ch in chname]

    bad = SegmentList()
    for i,segment in enumerate(segmentlist):
        start,end = segment
        fname = './data/{0}_{1}_{2}_{3}.gwf'.format(trend,stype,int(start),int(end))
        try:
            data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
        except IOError as e:
            bad.append(segment)

        nodata = True in [0.0 in d.value for d in data.values()]
        bigeq = True in [0.5 < d.diff().abs().max().value for d in data.values()]
        flag = nodata or bigeq
        if flag:
            bad.append(segment)

        fname_img = './data/img_100M_300M_{0}_{1}.png'.format(int(start),int(end))
        if plot and not os.path.exists(fname_img):
            label = [d.replace('_','\_') for d in data]
            plot = data.plot(ylabel='Velocity [um/sec]',epoch=start,
                             ylim=(0,1),title='BLRMS\_100M\_300M')
            ax = plot.gca()
            ax.plot(data.values()[0].diff().abs(),'k--')
            ax.plot(data.values()[1].diff().abs(),'r--')
            ax.plot(data.values()[2].diff().abs(),'b--')
            ax.legend(label + ['X Diffs','Y Diffs','Z Diffs'])
            if flag:
                ax.axvspan(start, end, alpha=0.5, color='red')
            plot.savefig(fname_img)
            plot.close()
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,nodata,bigeq
    segmentlist -= bad
    bad.write('baddata.txt')
    return segmentlist

def plot_asd(segment,data,fname_img,**kwargs):
    '''
    '''
    axis = ['X','Y','Z']    
    fig ,ax = plt.subplots(1,1)
    nproc = kwargs.pop('nproc',2)
    for i,d in enumerate(data.values()):
        sg = d.spectrogram2(fftlength=100, overlap=50,nproc=nproc) ** (1/2.)
        asd = sg.percentile(50)
        fname_hdf5 = './data/sg_{0}_{1}_{2}.hdf5'.format(axis[i],int(start),int(end))
        sg.write(fname_hdf5,format='hdf5',overwrite=True)
        #print 'Write {0}'.format(fname_hdf5)
        ax.loglog(asd,label=d.name.replace('_','\_'))                
    ax.legend(loc='lower left')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig(fname_img)
    plt.close()


def save_spectrogram(segmentlist,chname,plot=True,nproc=2,write=True,nodata=False,trend='full',stype=''):
    '''
    '''
    print('Save spectrograms ')
    bad = SegmentList()
    chname = [ch.split(',')[0] for ch in chname]
    for i,segment in enumerate(segmentlist):
        start,end = segment
        fname = './data/{0}_{1}_{2}_{3}.gwf'.format(trend,stype,int(start),int(end))
        try:
            data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
        except:            
            nodata = True
        label = [d.replace('_','\_') for d in data]
        fname_img = './data/img_ASD_{0}_{1}.png'.format(int(start),int(end))
        if os.path.exists(fname_img):
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,'Exist'
        elif not nodata and plot:
            kwargs={'nproc':nproc}
            plot_asd(segment,data,fname_img,**kwargs)
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,'Plotting..'
        elif nodata:
            print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,'No Data'
        else:
            raise ValueError('!')
            
if __name__ == "__main__":
    import warnings
    warnings.filterwarnings('ignore')

    start = int(tconvert("Feb 01 2019 00:00:00 JST"))
    end = int(tconvert("Jun 01 2019 00:00:00 JST"))

    # ----------------------------------------    
    print('Check whether earthquake or lack of data happen in segment.')
    # ----------------------------------------
    chname = ['K1:PEM-SEIS_EXV_GND_X_BLRMS_100M_300M_OUT16',
              'K1:PEM-SEIS_EXV_GND_Y_BLRMS_100M_300M_OUT16',
              'K1:PEM-SEIS_EXV_GND_Z_BLRMS_100M_300M_OUT16']
    noEQ = random_segments(start,end,tlen=3600,n=5,write=False,seed=3434)
    save_timeseriesdict(noEQ,chname,nds=False,trend='minute',stype='rms',nproc=10)
    noEQ = check_badsegment(noEQ,chname,nproc=10,stype='rms',trend='minute')
    noEQ.write('noEQ.txt')

    # ----------------------------------------    
    print('Calculate spectrograms with stationary data')
    # ----------------------------------------    
    noEQ = SegmentList.read('noEQ.txt')
    chname = ['K1:PEM-SEIS_EXV_GND_X_OUT16',
              'K1:PEM-SEIS_EXV_GND_Y_OUT16',
              'K1:PEM-SEIS_EXV_GND_Z_OUT16']
    save_timeseriesdict(noEQ,chname,nds=False,trend='full',nproc=10)
    save_spectrogram(noEQ,chname,nproc=10)

    # ----------------------------------------    
    print('Calculate avelage of all spectrograms')
    # ----------------------------------------    
    exit()
    sg  = Spectrogram.read('./data/sg_X_1234209537_1234213137.hdf5',format='hdf5')
    sg.append(Spectrogram.read('./data/sg_X_1234587670_1234591270.hdf5',format='hdf5'),gap='ignore')
    print len(sg)

    fig ,ax = plt.subplots(1,1)
    median = sg.percentile(50)
    low = sg.percentile(5)
    high = sg.percentile(95)
    ax.plot_mmm(median, low, high, color='gwpy:ligo-hanford')    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig('hoge.png')
    plt.close()

    fig ,ax = plt.subplots(1,1)
    median = _sg.percentile(50)
    low = _sg.percentile(5)
    high = _sg.percentile(95)
    ax.plot_mmm(median, low, high, color='gwpy:ligo-hanford')    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig('huge.png')
    plt.close()    
