#
#! coding:utf-8
import os

from numpy.random import randint
import numpy as np
import traceback

import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt

import subprocess
from gwpy.segments import Segment,SegmentList,DataQualityFlag
from gwpy.time import tconvert
from gwpy.timeseries import TimeSeries,TimeSeriesDict
from gwpy.frequencyseries import FrequencySeries
from gwpy.spectrogram import Spectrogram

from Kozapy.utils import filelist
import logger
log = logger.Logger('main')
gwf_fmt = './data/{0}_{1}_{2}_{3}.gwf'
img_fmt = './data/img_ASD_{0}_{1}.png'
img_ts_fmt = './data/img_TS_{0}_{1}_{2}_{3}.png'
sg_fmt = './data/sg_{axis}_{s}_{e}.hdf5'

__author__ = 'Koseki Miyo'

''' Seismic Noise

This module can do this;
 * 


'''



def check_chname(start,end):
    '''
    '''
    #K1:PEM-EX1_SEIS_WE_SENSINF_IN1_DQ : 1203897618 - 1216771218 , 2018-03-01T00:00:00 - 2018-07-28T00:00:00
    #K1:PEM-EXV_SEIS_WE_SENSINF_IN1_DQ : 1216857618 - 1227139218 , 2018-07-29T00:00:00 - 2018-11-25T00:00:00 
    #K1:PEM-EXV_GND_TR120Q_X_IN1_DQ    : 1227571218 - 1232668818 , 2018-11-30T00:00:00 - 2019-01-28T00:00:00  
    #K1:PEM-SEIS_EXV_GND_X_IN1_DQ      : 1232668818 - <>         , 2019-01-28T00:00:00 - <>
    if start > 1232668818:
        chname = ['K1:PEM-SEIS_EXV_GND_EW_IN1_DQ',
                  'K1:PEM-SEIS_EXV_GND_NS_IN1_DQ',
                  'K1:PEM-SEIS_EXV_GND_UD_IN1_DQ']
    elif 1227571218 < start and start < 1232668818:
        chname = ['K1:PEM-EXV_GND_TR120Q_X_IN1_DQ',
                  'K1:PEM-EXV_GND_TR120Q_Y_IN1_DQ',
                  'K1:PEM-EXV_GND_TR120Q_Z_IN1_DQ']
    elif 1216857618 < start and start < 1227139218:
        chname = ['K1:PEM-EXV_SEIS_WE_SENSINF_IN1_DQ',
                  'K1:PEM-EXV_SEIS_NS_SENSINF_IN1_DQ',
                  'K1:PEM-EXV_SEIS_Z_SENSINF_IN1_DQ']
    elif 1203897618 < start and start < 1227571218:
        chname = ['K1:PEM-EX1_SEIS_WE_SENSINF_IN1_DQ',
                  'K1:PEM-EX1_SEIS_NS_SENSINF_IN1_DQ',
                  'K1:PEM-EX1_SEIS_Z_SENSINF_IN1_DQ']
    else:
        chname = None
    return chname

def fw_segments(fw_name='fw0',scp=False):
    ''' Return the segment list when the frame writer could write data.

    Information about when the fw0 write data is given by a text file named "fw0-latest.txt".  This text file is generated by a script written by T. Yamamoto. Then we can make a segment list by translating this file.

    "fw0-latest.txt" is saved on /users/DGS/Frame.

    Parameters
    ----------
    fw_name : `str`, optional
        Name of the frame writer. KAGRA have a fw0 and fw1. Default is fw0.
    scp : `str`, optional
        If download from control machine, please choose True. In default, False.

    Returns
    -------
    ok : `gwpy.segments.SegmentList`
        SegmentList whihch only contain segments when fw has write data on main strage.
    '''
    if scp:
        cmd = 'scp controls@k1ctr7:/users/DGS/Frame/{0}-latest.txt ./ '.format(fw_name)
        download = subprocess.call(cmd, shell=True)

    cmd = "less ./{0}-latest.txt".format(fw_name) 
    cmd += " | awk '{if ($4>86400) print $1 , $2}' > tmp_{0}.txt".format(fw_name)
    make_tmp_txt = subprocess.call(cmd,shell=True)
    ok = SegmentList.read('tmp_{0}.txt'.format(fw_name))
    remove_tmp_txt = subprocess.call("rm tmp_{0}.txt".format(fw_name), shell=True)
    return ok


def random_segments(start,end,tlen=3600,n=200,seed=3434):
    ''' Return segment list randomly in term you designated
    
        
    Parameters
    ----------
    start : `float`
        Start time 
    end : `float`
        End time
    n : `int`, optional
        The number of segments
    seed : `int`, optional
        Seed. 3434 is a default value.
    tlen : `int`, optional
        Duration. default is 3600 seconds.    
    write : `Bool`, optional
        If True, segmentlist is written in local directory. Default is True.

    Returns
    -------
    segmentlist : `gwpy.segments.SegmentList`
        SegmentList.
    '''
    np.random.seed(seed=seed)        
    _start = randint(start,end,size=n)
    _end = _start + tlen
    segmentlist = SegmentList(map(Segment,zip(_start,_end)))
    return segmentlist

def read_and_write_timeseries(sources,start,end,fname,**kwargs):
    '''
    '''
    chname = check_chname(start,end)
    nds = kwargs.pop('nds',True)
    try:
        if nds:
            data = TimeSeriesDict.fetch(chname,host='10.68.10.122',port=8088,verbose=False,pad=0.0)            
        else:
            data = TimeSeriesDict.read(sources,chname,**kwargs)
        data = data.resample(32)
        data = data.crop(start,end)
        assert None not in [d.name for d in data.values()], 'not exit!'
        data.write(fname,format='gwf.lalframe')
        ok = True
    except ValueError as e:       
        log.debug(traceback.format_exc())
        ok = False
    except RuntimeError as e:       
        log.debug(traceback.format_exc())
        log.debug(chname)
        ok = False
        #exit()
    except TypeError as e:       
        log.debug(traceback.format_exc())
        log.debug(chname)
        ok = False
        #exit()
    except:
        log.debug(traceback.format_exc())
        raise ValueError('Unknown error. Please comfirm.')
    return ok

def save_timeseriesdict(seglist,nds=True,trend='full',stype='',nproc=2):
    ''' 
    
    '''
    log.debug('Save timeseriesdict..')
    
    for i,segment in enumerate(seglist):
        start, end = segment
        sources = filelist(start,end,trend=trend,place='kashiwa')
        fname = gwf_fmt.format(trend,stype,start,end)
        chname = check_chname(start,end)
        if not trend=='full':
            chname = [ch+'.'+stype for ch in chname]
        if trend=='full':
            stype = ''
        if not os.path.exists(fname):
            kwargs = {'format':'gwf.lalframe','nproc':nproc,'pad':0.0,'nds':nds}
            ok = read_and_write_timeseries(sources,start,end,fname,**kwargs)
            if ok:
                log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname)+'Saving..')
            else:
                log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname)+'No Data')
        else:
            log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname)+'File exist')
    

def _check_badsegment(segment,trend='full',stype=''):
    '''
    1 bit : no data
    2 bit : lack of data
    3 bit : missed caliblation 
    4 bit : big earthquake
    '''
    start,end = segment        
    fname = gwf_fmt.format(trend,stype,start,end)
    chname = check_chname(start,end)
    try:
        data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
        lack_of_data = any([0.0 in d.value for d in data.values()] )*4
        miss_calib = any([ 1000.0 < d.mean() for d in data.values()])*8
        bigeq = any([any((d.std()*6)<(d-d.mean()).abs().value) for d in data.values()])*16
        return data, (lack_of_data + miss_calib + bigeq)
    except IOError as e:
        nodata = (True)*2
        return None, nodata
    except ValueError as e:
        if 'Cannot append discontiguous TimeSeries' in e.args[0]:
            log.debug(e)
            nodata = (True)*2
            return None, nodata
        else:
            log.debug(traceback.format_exc())
            raise ValueError('!!')
    except:
        log.debug(traceback.format_exc())
        raise ValueError('!!!')


def plot_timeseries(data,start,end,bad_status,fname_img):
    '''
    '''
    fig = plt.figure(figsize=(15, 10))
    plt.suptitle('Seismometer at 2nd floor in X-end (EXV) {0}'.format(bad_status),fontsize=30)
    grid = plt.GridSpec(3, 6, hspace=0.4, wspace=0.5)
    
    if not data:
        return False

    for i,d in enumerate(data.values()):
        main_ax = fig.add_subplot(grid[i, :-1])
        main_ax.plot(d,label=d.name.replace('_','\_'))
        main_ax.set_ylabel('Velocity [um/sec]')
        main_ax.set_xscale('minutes')
        main_ax.legend()
        main_ax.plot([start,end],[d.mean(),d.mean()],'k')
        std5 = d.std()*5
        std10 = d.std()*10
        mean = d.mean()
        main_ax.plot([start,end],[mean+std5,mean+std5],'k')
        main_ax.plot([start,end],[mean-std5,mean-std5],'k')
        x_hist = fig.add_subplot(grid[i,-1],sharey=main_ax)
        x_hist.hist(d.value,bins=50,orientation=u'horizontal',histtype='step',)
        main_ax.set_ylim(mean-std10,mean+std10)
        x_hist.set_ylim(mean-std10,mean+std10)
        if bad_status:
            main_ax.axvspan(start, end, alpha=0.5, color='red')
    plt.savefig(fname_img)
    plt.close()


def check_badsegment(seglist,plot=True,nproc=2,stype='',trend='full'):
    '''

    '''
    log.debug('Checking bad segments')
    
        
    status = {2:'no_data',
              4:'lack_of_data',
              8:'miss_calib',
              16:'big_eq'}

    bad = SegmentList()
    for i,segment in enumerate(seglist):
        data,bad_status = _check_badsegment(segment,trend='full',stype='')
        if bad_status:
            bad.append(segment)
        start,end = segment        
        fname_img = img_ts_fmt.format(trend,stype,start,end)
        chname = check_chname(start,end)
        if not trend=='full':
            chname = [ch+'.'+stype for ch in chname]
        if plot and not os.path.exists(fname_img):
            plot_timeseries(data,start,end,bad_status,fname_img)
            log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname_img))

    # 
    new = SegmentList()    
    for segment in seglist:
        flag = 0
        for _bad in bad:
            if segment != _bad:
                flag += 1
            else:
                break
        if flag==len(bad):
            new.append(segment)
    return new,bad


def plot_asd(segment,data,fname_img,fname_hdf5,**kwargs):
    '''
    '''
    axis = ['X','Y','Z']    
    fig ,ax = plt.subplots(1,1)
    nproc = kwargs.pop('nproc',2)
    for i,d in enumerate(data.values()):
        sg = d.spectrogram2(fftlength=100, overlap=50,nproc=nproc) ** (1/2.)
        asd = sg.percentile(50)        
        _fname_hdf5 = fname_hdf5.format(axis=axis[i])
        log.debug(' -: {0} '.format(_fname_hdf5)+'Save')
        sg.write(_fname_hdf5,format='hdf5',overwrite=True)
        ax.loglog(asd,label=d.name.replace('_','\_'))
    ax.legend(loc='lower left')
    ax.set_ylim(5e-3,50)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig(fname_img)
    plt.close()


def save_spectrogram(seglist,plot=True,nproc=2,write=True,nodata=False,trend='full',stype=''):
    '''
    
    '''    
    log.debug('Save spectrograms ')
    bad = SegmentList()
    for i,segment in enumerate(seglist):
        start,end = segment        
        fname = gwf_fmt.format(trend,stype,start,end)
        chname = check_chname(start,end)
        try:
            log.debug(fname)
            data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
            data = data.crop(start,end)
            # DEBUG: Returning FrameH::Subset: 0 for frame at offset:
            # 0 with 0 type elements with 0 user elements with 0 detectSim lements with 0
            # detectProc elements with 1 history elements with 0 auxData elements with 0 auxTable elements
        except:
            nodata = True
        label = [d.replace('_','\_') for d in data]
        fname_img = img_fmt.format(start,end)
        fname_hdf5 = sg_fmt.format(axis='{axis}',s=start,e=end)
        if os.path.exists(fname_img):
            log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname_img)+'Exist')
        elif not nodata and plot:
            kwargs={'nproc':nproc}
            plot_asd(segment,data,fname_img,fname_hdf5,**kwargs)
            log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname_img)+'Plot')
        elif nodata:
            log.debug('{0:03d}/{1:03d} {2} '.format(i,len(seglist),fname_img)+'No Data')
        else:
            raise ValueError('!')


def plot_averaged_asd(specgrams):
    '''
    '''
    fig ,ax = plt.subplots(1,1,figsize=(7,7))
    median = specgrams.percentile(50)
    low = specgrams.percentile(5)
    high = specgrams.percentile(95)
    ax.plot_mmm(median, low, high, color='black')    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(5e-3,50)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    fname_hdf5 = './data/ASD_LongTerm_{0}.hdf5'.format(axis)
    plt.savefig('./data/img_ASD_LongTerm_{0}.png'.format(axis))
    log.debug('Plot ./data/img_ASD_LongTerm_{0}.png'.format(axis))
    specgrams.write(fname_hdf5,format='hdf5',overwrite=True)
    plt.close()


def plot_segmentlist(random,bad,good,start,end):
    '''
    '''    
    good = DataQualityFlag(name='Good',active=good,known=[(start,end)])
    bad = DataQualityFlag(name='Bad',active=bad,known=[(start,end)])
    random = DataQualityFlag(name='Random',active=random,known=[(start,end)])
    plot = good.plot(figsize=(15,5),epoch=start)
    ax = plot.gca()
    ax.plot(bad)
    ax.plot(random)
    plt.savefig('./data/segment.png')
    #exit()


def allsegmentlist(start,end,tlen=2**12):
    '''
    
    Parameters
    ----------
    start : `int`
        GPS start time of designated 
    end : `int`
    
    '''
    seglist = SegmentList()
    i = 0
    while True:
        if start+(i+1)*tlen >= end:
            break
        else:
            seglist.append(Segment(start+i*tlen,start+(i+1)*tlen))
            i += 1
    return seglist
            
if __name__ == "__main__":
    import warnings
    warnings.filterwarnings('ignore')
    
    # ----------------------------------------    
    # Setting
    # ----------------------------------------    
    segnum = 5
    seed = 3434
    start = int(tconvert("Jun 01 2018 00:00:00 JST"))
    end = int(tconvert("Jun 02 2018 00:00:00 JST"))
    nproc = 16
    trend = 'full'

    # ----------------------------------------    
    log.info('Saving all time-series as gwf')
    # ----------------------------------------
    #random = random_segments(start,end,tlen=3600,n=segnum,seed=seed)
    #random.write('random.txt')
    #base = random
    base = allsegmentlist(start,end)
    base.write('base.txt')
    #save_timeseriesdict(base,nds=False,trend='full',nproc=nproc)
    
    # ----------------------------------------    
    log.info('Checking bad segments')
    # ----------------------------------------    
    good,bad = check_badsegment(base,trend='full',nproc=nproc)
    good.write('good.txt')
    bad.write('bad.txt')
    log.debug('{0} - {1} = {2}'.format(len(base),len(bad),len(good)))
    plot_segmentlist(base,bad,good,start,end)
    
    # ----------------------------------------    
    log.info('Saving spectrogram data as hdf5')
    # ----------------------------------------        
    save_spectrogram(good,nproc=nproc)
    
    # ----------------------------------------    
    log.info('Calculate averaged ASD')
    # ----------------------------------------            
    axis = 'Z'
    fname = filter(lambda x: "sg_{0}".format(axis) in x, os.listdir('./data'))
    fname = map(lambda x:'./data/'+x,fname)
    specgrams = Spectrogram.read(fname[0],format='hdf5')
    for fname in fname[1:]:
        specgrams.append(Spectrogram.read(fname,format='hdf5'),gap='ignore')        
    plot_averaged_asd(specgrams)    
