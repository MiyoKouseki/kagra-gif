#
#! coding:utf-8
import os
from numpy.random import rand
import numpy as np

import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt

import subprocess
from gwpy.segments import Segment,SegmentList,DataQualityFlag
from gwpy.time import tconvert
from gwpy.timeseries import TimeSeries,TimeSeriesDict
from gwpy.frequencyseries import FrequencySeries
from gwpy.spectrogram import Spectrogram

from Kozapy.utils import filelist


def fw_segments(fw_name='fw0',scp=False):
    ''' Return the segment list when the frame writer could write data.

    Information about when the fw0 write data is given by a text file named "fw0-latest.txt".  This text file is generated by a script written by T. Yamamoto. Then we can make a segment list by translating this file.

    "fw0-latest.txt" is saved on /users/DGS/Frame.

    Parameters
    ----------
    fw_name : `str`, optional
        Name of the frame writer. KAGRA have a fw0 and fw1. Default is fw0.
    scp : `str`, optional
        If download from control machine, please choose True. In default, False.

    Returns
    -------
    ok : `gwpy.segments.SegmentList`
        SegmentList whihch only contain segments when fw has write data on main strage.
    '''
    if scp:
        cmd = 'scp controls@k1ctr7:/users/DGS/Frame/{0}-latest.txt ./ '.format(fw_name)
        download = subprocess.call(cmd, shell=True)

    cmd = "less ./{0}-latest.txt".format(fw_name) 
    cmd += " | awk '{if ($4>86400) print $1 , $2}' > tmp_{0}.txt".format(fw_name)
    make_tmp_txt = subprocess.call(cmd,shell=True)
    ok = SegmentList.read('tmp_{0}.txt'.format(fw_name))
    remove_tmp_txt = subprocess.call("rm tmp_{0}.txt".format(fw_name), shell=True)
    return ok


def random_segments(start,end,tlen=3600,n=200,seed=3434,write=True):
    ''' Return segment list randomly in term you designated
    
        
    Parameters
    ----------
    start : `float`
        Start time 
    end : `float`
        End time
    n : `int`, optional
        The number of segments
    seed : `int`, optional
        Seed. 3434 is a default value.
    tlen : `int`, optional
        Duration. default is 3600 seconds.    
    write : `Bool`, optional
        If True, segmentlist is written in local directory. Default is True.

    Returns
    -------
    segmentlist : `gwpy.segments.SegmentList`
        SegmentList.
    '''
    np.random.seed(seed=seed)        
    _start = start*np.ones(n) + (end-start)*rand(n)
    _end = _start + tlen
    segmentlist = SegmentList(map(Segment,zip(_start,_end)))
    if write:
        segmentlist.write('random.txt')
        print('saved random.txt')
    return segmentlist
    

def save_gwf(segmentlist,chname,nds=True,trend='minute',stype='rms',nproc=2):
    ''' 
    
    '''
    print('save gwf files')
    if nds and (trend=='minute') and (stype=='rms'):
        for i,segment in enumerate(segmentlist):
            start,end = segment
            fname = './data/mtrend_rms_{0}_{1}.gwf'.format(int(start),int(end))
            if os.path.exists(fname):
                pass
            else:
                data = TimeSeriesDict.fetch(chname,start,end,
                                            host='10.68.10.122',
                                            port=8088,verbose=False,
                                            pad=0.0)
                assert None not in [d.name for d in data.values()], 'not exit!'
                data.write(fname,format='gwf.lalframe')
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname            
    elif not nds and (trend=='minute') and (stype=='rms'):
        chname = [ch.split(',')[0] for ch in chname]
        for i,segment in enumerate(segmentlist):
            start,end = segment
            sources = filelist(start,end,trend='mtrend',place='kashiwa')        
            fname = './data/mtrend_rms_{0}_{1}.gwf'.format(int(start),int(end))
            if os.path.exists(fname):
                pass
            else:
                data = TimeSeriesDict.read(sources,chname,format='gwf.lalframe',
                                           nproc=nproc,
                                           start=start,end=end)
                assert None not in [d.name for d in data.values()], 'not exit!'
                data.write(fname,format='gwf.lalframe')
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname
    elif not nds and (trend=='full'):
        chname = [ch.split('.')[0] for ch in chname]
        for i,segment in enumerate(segmentlist):
            start,end = segment
            sources = filelist(start,end,trend='full',place='kashiwa')        
            fname = './data/full_{0}_{1}.gwf'.format(int(start),int(end))
            if os.path.exists(fname):
                pass
            else:
                data = TimeSeriesDict.read(sources,chname,format='gwf.lalframe',
                                           nproc=nproc,pad=0.0, # dont use pad!!
                                           start=start,end=end)
                assert None not in [d.name for d in data.values()], 'not exit!'
                data.write(fname,format='gwf.lalframe')
                print '{0:03d}/{1:03d}'.format(i,len(segmentlist)),fname
    else:
        raise('!')
    

def check_badsegment(segmentlist,chname,plot=True,nproc=2):
    '''
    '''
    print('check bad segments')
    bad = SegmentList()
    chname = [ch.split(',')[0] for ch in chname]
    for i,segment in enumerate(segmentlist):
        start,end = segment
        fname = './data/mtrend_rms_{0}_{1}.gwf'.format(int(start),int(end))       
        data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
        label = [d.replace('_','\_') for d in data]
        fname_img = './data/img_100M_300M_{0}_{1}.png'.format(int(start),int(end))
        nodata = True in [0.0 in d.value for d in data.values()]
        bigeq = True in [0.5 < d.diff().abs().max().value for d in data.values()]
        flag = nodata or bigeq
        print '1, {0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img,nodata,bigeq
        if plot and not os.path.exists(fname_img):
            plot = data.plot(ylabel='Velocity [um/sec]',epoch=start,
                             ylim=(0,1),title='BLRMS\_100M\_300M')
            ax = plot.gca()
            ax.plot(data.values()[0].diff().abs(),'k--')
            ax.plot(data.values()[1].diff().abs(),'r--')
            ax.plot(data.values()[2].diff().abs(),'b--')
            ax.legend(label + ['X Diffs','Y Diffs','Z Diffs'])
            if flag:
                ax.axvspan(start, end, alpha=0.5, color='red')
                bad.append(segment)
            plot.savefig(fname_img)
            plot.close()
        else:
            pass
    segmentlist -= bad
    bad.write('baddata.txt')
    return segmentlist

def make_asd(segmentlist,chname,plot=True,nproc=2,write=True):
    '''
    '''
    print('make asd ')
    bad = SegmentList()
    chname = [ch.split(',')[0] for ch in chname]
    axis = ['X','Y','Z']
    for i,segment in enumerate(segmentlist):
        start,end = segment
        fname = './data/full_{0}_{1}.gwf'.format(int(start),int(end))       
        data = TimeSeriesDict.read(fname,chname,nproc=nproc,verbose=False)
        label = [d.replace('_','\_') for d in data]
        fname_img = './data/img_ASD_{0}_{1}.png'.format(int(start),int(end))
        if plot and not os.path.exists(fname_img):
            fig ,ax = plt.subplots(1,1)
            for i,d in enumerate(data.values()):
                sg = d.spectrogram2(fftlength=100, overlap=50,nproc=nproc) ** (1/2.)
                asd = sg.percentile(50)
                fname_hdf5 = './data/sg_{0}_{1}_{2}.hdf5'.format(axis[i],int(start),int(end))
                sg.write(fname_hdf5,format='hdf5',overwrite=True)
                print 'Write {0}'.format(fname_hdf5)
                ax.loglog(asd)                
            ax.legend(label,loc='lower left')
            ax.set_ylim(5e-5,2)
            ax.set_ylabel('Velocity [um/sec/rtHz]')
            ax.set_xlabel('Frequency [Hz]')
            plt.savefig(fname_img)
            plt.close()
            print '1, {0:03d}/{1:03d}'.format(i,len(segmentlist)),fname_img
        else:
            pass
            
if __name__ == "__main__":
    import warnings
    warnings.filterwarnings('ignore')

    start = int(tconvert("Feb 01 2019 00:00:00 JST"))
    end = int(tconvert("Jun 01 2019 00:00:00 JST"))

    chname = [
        'K1:PEM-SEIS_EXV_GND_X_OUT16.rms,m-trend',        
        'K1:PEM-SEIS_EXV_GND_X_BLRMS_30M_100M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_X_BLRMS_100M_300M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_X_BLRMS_300M_1_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Y_OUT16.rms,m-trend',                
        'K1:PEM-SEIS_EXV_GND_Y_BLRMS_30M_100M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Y_BLRMS_100M_300M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Y_BLRMS_300M_1_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Z_OUT16.rms,m-trend',                
        'K1:PEM-SEIS_EXV_GND_Z_BLRMS_30M_100M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Z_BLRMS_100M_300M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Z_BLRMS_300M_1_OUT16.rms,m-trend',        
        ]
    chname = [
        'K1:PEM-SEIS_EXV_GND_X_BLRMS_100M_300M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Y_BLRMS_100M_300M_OUT16.rms,m-trend',
        'K1:PEM-SEIS_EXV_GND_Z_BLRMS_100M_300M_OUT16.rms,m-trend',
        ]                
    data_segment = random_segments(start,end,tlen=3600,n=100,write=False)
    print(data_segment)
    save_gwf(data_segment,chname,nds=False,trend='minute',stype='rms',nproc=10)
    data_segment = check_badsegment(data_segment,chname,nproc=10)
    data_segment.write('noEQ.txt')
    data_segment = SegmentList.read('noEQ.txt')
    chname = [
        'K1:PEM-SEIS_EXV_GND_X_OUT16',
        'K1:PEM-SEIS_EXV_GND_Y_OUT16',
        'K1:PEM-SEIS_EXV_GND_Z_OUT16',
        ]
    save_gwf(data_segment,chname,nds=False,trend='full',nproc=10)
    make_asd(data_segment,chname,nproc=10)
    
    exit()
    sg  = Spectrogram.read('./data/sg_X_1234209537_1234213137.hdf5',format='hdf5')
    sg.append(Spectrogram.read('./data/sg_X_1234587670_1234591270.hdf5',format='hdf5'),gap='ignore')
    print len(sg)

    fig ,ax = plt.subplots(1,1)
    median = sg.percentile(50)
    low = sg.percentile(5)
    high = sg.percentile(95)
    ax.plot_mmm(median, low, high, color='gwpy:ligo-hanford')    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig('hoge.png')
    plt.close()

    fig ,ax = plt.subplots(1,1)
    median = _sg.percentile(50)
    low = _sg.percentile(5)
    high = _sg.percentile(95)
    ax.plot_mmm(median, low, high, color='gwpy:ligo-hanford')    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.set_ylim(5e-5,2)
    ax.set_ylabel('Velocity [um/sec/rtHz]')
    ax.set_xlabel('Frequency [Hz]')
    plt.savefig('huge.png')
    plt.close()
    
    #TimeSeries 1 span: [1236339947.75 ... 1236341248.0)
    #TimeSeries 2 span: [1236341344.0 ... 1236341376.0)
